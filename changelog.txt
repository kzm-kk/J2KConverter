2021/11/18
for文構築の箇所のアルゴリズム変更
変数宣言時の代入式右辺(初期値)の処理
2021/11/23
コマンドライン用のシェルスクリプト作成
配列の様々な初期化方法に対する変換記述の追加
2021/11/24
BlockVisitor(ブロック内部を構成するための入り口生成visitor)の仕組み変更
上記に伴う出力微調整
メソッド呼び出し記述のargument処理の方法変更
2021/11/25
if文のelse ifの生成方法を修正
switch-case文への対応
計算式への対応
2021/11/30
変換前の情報収集用のシステム開発開始
2021/12/02
クラスの持つフィールドに対し、クラス内における代入文(ASSIGN文)の有無の確認システム作成
get/setアクセサをプロパティに内包できるかどうかの判断システム作成
2021/12/03
情報収集プログラムJ2KConverterSupporterと変換プログラムJ2KConverterの接続開始
メソッドの持つ情報の中の取得する情報として行数を追加
varかvalかの判断データを変換機能に使用
配列データの深さを変換機能に使用
2021/12/06
プロパティに内包される標準アクセサ及びカスタムアクセサ記述用の仕組みを制作開始
アクセサメソッドがどのフィールドに対する情報かを保存
2021/12/07
get/setが両方プロパティのアクセサとして変換できる時のみ標準アクセサ変換時のprivate修飾子を削除するアルゴリズム記述
カスタムアクセサを記述するvisitorの制作
初期値のない変数に対する仮初期値の作成
2021/12/11
ローカル変数のvar/valの判断用情報の格納先作成、判断データを受けて変換する機能作成、判断機能作成
一部即値用のvisitorを変換用プログラムに追加
プロパティが内包する標準アクセサ及びカスタムアクセサにするget/setメソッドの呼び出し箇所の変換機能作成
2021/12/13
interfaceかclassかの判別及びそれによる変換記述の変更を追加
サンプルプログラムを変換した際に変換しきれていない文言を調査、変換機能調整
@Overrideアノテーションへの対応開始
コンストラクタ内の代入記述捜索用のvisitor制作開始
2021/12/14
コンストラクタ捜査用visitor作成
2021/12/15
companion objectへの変換対応開始
staticフィールドの変換機能制作
staticメソッドの変換機能制作及びそれに関する収集情報の追加
package宣言、import宣言の文言追加
ver0.1完成
2021/12/17
ver0.2制作開始
複数プログラム一括変換用の変換機能制作開始
2021/12/21
複数プログラム一括変換用の変換機能の仕様変更
foreach文への対応
2021/12/27
ファイル出力関連のクラスConvertOutputer制作
System.out.print系の出力先をファイルに変更
自動変換できない記述・JavaParserが例外を返す記述の発見
ver0.3制作開始
2022/01/04
JavaParserライブラリバージョン変更3.16.1→3.23.1
Kotlinバージョン変更1.5.30→1.6.0
Kotlinコンパイル系統バージョン変更1.8→15
parserをStaticJavaParserからJavaParserに変更
2022/01/05
return文で返す値のコンバート方法変更
2022/01/06
三項演算子、do-while、try-catch-finally変換の実装開始
2022/01/07
列挙型、可変長変数、ラムダ文変換の実装開始
2022/01/11
try-catch-finally, 三項演算子, do-while実装
2022/01/13
複数プログラムコンバート、単一プログラムコンバートに差異がなかったのでコンバート用プログラムをJ2KConvertに集約
(情報収集は仕組みが異なるので単一、複数をそれぞれ実装)
列挙型クラス本体の変換機能実装(アクセス文言はまだ)
ver0.3制作終了、ラムダ式、キャスト、可変長変数はver0.4に持ち越し
2022/01/24
ver0.4制作開始
ラムダ式の変換機能を実装(完全には理解してないのでそれっぽいものだけ)
2022/01/27
binaryExpr(計算式)の解析・出力方法の詳細化完了
binaryExpr関連のキャスト、かっこ(enclosed)の変換対応
2022/02/08
argumentの変換機能の変更に着手
上記に伴いメソッド呼び出し記述(MethodCallExpr)の変換の改良に着手
binaryExpr(記号で足された記述)の解析→argumentの変換機能の変更で対応できそう
2022/02/09
operator(演算記号)の文字列⇨記号変換のためのメソッドSignOperator実装
MethodCallExprの変換の統一化(InClassVisitorとAssignVisitorにそれぞれ存在していたものをAssignVisitor側に集約)
2022/02/14
BinaryExprにおける演算記号データの取得方法の改善(getOperator().toString()→getOperator().name())
MethodCallExprのscope部分の変換方法変更
パッケージ名、インポートの出力方法を変更
2022/02/21
無名クラス、ジェネリッククラス、初期化子、メソッド参照の実装開始(この日はdebugによる解析のみ)
2022/02/24
無名クラス(AnonymousClassBody),初期化子(InitializeDeclaration), メソッド参照(MethodReference)の変換機能実装
2022/02/25
初期化子変換時のstaticの有無の考慮反映、ラムダ式の変換をAssignVisitorに追加、ダイヤモンド演算子に対応
2022/03/02
ラムダ文の解析を調整
開発内容をJ2KConverterに反映
出力方法を直接printlnではなく変数を介する方法に変更
上記に伴いコードの整理開始
2022/03/03
出力方法の変更に伴うコードの整理→完了、変数assignRight消去
for文の変換をwhile文になるように変更(後々 whileにするかforにするか決める)
2022/03/04
ラムダ式変換のためのコード改良(省略なしなら変換可能)
初期化子のstaticに対応(Datastore.isStaticIでフラグ管理)
2022/03/08
ワイルドカード関連の調査
parameter変換のためのvisitor作成開始
2022/03/14
ジェネリックス、ワイルドカード変換に伴い型の変換出力方法変更
ジェネリックス、ワイルドカードの変換(? super Tに準ずるものは調査中)
ver0.4製作完了、0302以降のコードのJ2KConverterへの反映、ver0.5製作開始
CompanionObjectVisitorの変換機能をOutClassVisitorに統一化、CompanionObjectVisitor削除
上記に伴い、OutClassVisitorにcompanionObjectの変換か否かを示す変数isCompanionConvertを追加
2022/03/15
parameterの変換機能の変更、可変長引数の変換もこの中に入る(ラムダ式はまだ)(してない？)
2022/03/18
変換の際、インナークラスとそうでないクラス、及びその内部の変換方法の変更
上記に伴い、Visitorの名称変更(下に示す)
FirstStepVisitor → OutClassVisitor
OutClassVisitor  → InClassVisitor
BlockVisitor     → MakeBlockVisitor
InClassVisitor   → InBlockVisitor
0314以降の更新内容のConverterへの反映
メソッドチェーンへの対応確認
2022/04/05
synchronizedに対する変換機能を追加
クラスのインスタンス生成時の実行順番に置ける変数のチェック順番をコメントで記載
Supporter側に初期化子の構文木を参照する機能を追加、保存場所も追加
2022/04/12
J2KConverterSupporterMultiに他のクラスの使用箇所を探る部分を追加
assert文への変換対応
2022/04/13
ラベル記述の変換への対応、それに伴うcontinue, break記述の変換の変更
明示的コンストラクタ呼び出し、ローカルクラスの学習開始
2022/04/15
アノテーションについての学習開始
2022/04/19
独自アノテーションクラスの変換機能作成
各部アノテーションの変換機能構築開始
2022/04/20
各部アノテーションの変換機能開発(AnnotationVisitor)
アノテーションクラス定義記述の変換機能(OutClassVisitor.visit(AnnotationDeclaration))
2022/04/22
明示的コンストラクタ呼び出しの変換機能作成
コンストラクタの変換にミスが見られたので正しい文法に修正
メソッドチェーンなどのscopeに見られるsuper,thisを出力するように調節
2022/04/24
フィールド参照、配列参照の変換を、文字列出力ではなく区切りごとに解析するように変更
2022/04/25
ローカルクラスの変換に対応
2022/05/05
0318以降の開発内容をConverterへ反映
ver0.5制作完了、ver0.6制作開始
2022/06/14
情報収集用のvisitorの仕組みを変更することを決定、仕組みの構築開始
2022/06/15
情報収集用のvisitorの仕組みを変更、一部を切り離して集約
複数プログラム版にも適用
2022/06/21
情報収集用のConverterSupporterを改良、アクセサメソッドの判断と、代入の有無やnullableの判断を今まで通りできるように
2022/06/22
ConverterSupporterをさらに改良、visitorによる解析をconverterに近いものに変更
2022/06/23
テスト用のプログラムにより、ConverterSupporterの挙動が想定通りになっていることを確認
(初期化子、コンストラクタの確認、ReadとWrite、どちらが先か、代入・計算式の解析)
2022/06/24
インクリメント系、if・while・do-whileのconditionチェックを追加
+=の記述がAssignExprであることを確認
2022/06/27
for文、switch文、メソッド呼び出しの引数部分の解析実装
+=などのイコールを含むAssign文の演算子に対応
メソッドの取得情報に返り値がnullになり得るか否かの情報項目nullableを追加
return記述から判断できるようにConverterSupporterに追加
ConverterSupporterにてテストした機能を複数プログラム版SupporterMultiに移植・改良
2022/06/28
全ての変数をnullableとして出力するように設定
オプション用の引数を追加し、今後、nullable出力とnon-null出力を選べるように設定
2022/06/29
フィールドや返り値を持つメソッドの出力をする際の!!後置演算子を出力する機能を追加
それに伴い、メソッドから収集する情報に返り値情報typeを追加、typeの表記は変数のtype情報と同じ
isNonNullフラグにより出力を変更する機能も追加、isNonNullにする際の出力変更は後日作成
2022/07/06
親ノードが配列だった際に、後置演算子を出力しない機能を作成。親ノードの確認はメソッドを作成
2022/07/08
配列の後置演算子出力に必要な情報を、必要なタイミングで取得できるような仕組みを作成
メソッド呼び出しの出力の箇所を修正
AssignExprのOperatorを判断・出力するAssignOperator関数作成
2022/07/11
localな変数のデータを呼び出すためのkeyをclassname methodnameからclassname rangeに変更
2022/07/12
列挙型に対応できるようにConverterSupporterMultiを改良
Multiでない単一プログラム変換機能はこの日以降使わないと思われる
ver0.6開発完了、ver0.7開発開始
2022/07/13
保存する情報の保存形式の変更開始、これはしばらくかかる見込み
変換結果を格納する変数OutputerをStringBuilderに変更
2022/07/15
FieldDeclaration, MethodDeclarationのみ、最初に構文木を解析する際に扱うXXXFirstVisitorと2回目以降に解析するXXXSecondVisitorに分けた。
2022/07/19
三つ組データを作るクラスTriplets, 2つのデータをkeyに、1つのデータをvalueにして扱うTwinKeyDataListを作成
2022/07/20
最初の解析・情報収集部分(J2KConverterSupporter line47)までの動作確認済み、出力問題なし
InBlockVisitorSまでの範囲で、新しい保存形式に対応する仕組みを実装。AssignVisitorS以下の階層に関しては後日
2022/07/22
変数の定義場所を探るための機能を作成(同一スコープや上位のスコープ、同一ファイル内まで)
上記の機能のうち、同一ディレクトリ内のプログラムからも探れるように
2022/07/25
AssignVisitorS以下の階層における新しい保存形式に対応する仕組みを実装
BlockInformationの情報の保持方法を変更。木形式になるように
それにより、保存する際のシステム面に変更が必要に
2022/07/27
BlockInformationのdequeを作ることにより、クラスから現在のスコープまでの流れを保存し、遡ることで保存できるように
１回目の解析の際に解析する範囲を追加。全ブロック文のローカルな変数定義までを保存するように
上記に伴い、コンストラクタ、初期化子などの１回目の解析を行うXXXFirstVisitorを追加
2022/08/01
elseifの扱いを構文木準拠のstructureに決定。今後、スコープ構造を記録するstructureは全て構文木準拠に
2022/08/02
上記の構文木準拠のstructureに伴い、else、switchのBlockInformationを常に生成するように表示
2回目の解析実行込みでのJ2KConverterSupporterMulti新保存様式の動作出力に成功
(一連の解析に成功しているみたいなのでおそらく3回目も成功すると予想)
2022/08/05
変換プログラム側のデータ呼び出し系統の、新保存様式への対応開始
CustomAccessorConverterのスーパークラスを変更
InClassVisitor_CACをInBlockVisitor_CACに名称変更
2022/09/12
変換プログラム側のデータ呼び出し系統の新保存様式への対応が大体完了&動作確認
(companion objectの出力、アクセサのカスタムコンバート、無名クラスの宣言は未対応)
2022/09/13
一部出力がおかしなところに対応
09/12の未対応にローカルクラス追加
2022/09/16
ClassInformationにそのクラスがstaticなものを含むか否かのboolean変数isContainStaticを追加
companion objectの出力に対応
型出力のvisitorの中身修正
2022/09/21
匿名クラス、ローカルクラスに対する情報収集用プログラムの実装
2022/09/26
２回目解析以降のデータの保存方法の変更
無名クラス、ローカルクラス、ラムダ式への対応
動作確認
2022/09/28
ver0.7開発完了、ver0.8開発開始
2022/10/03
ArrayInitializerExpr、ObjectCreationExprの解析追加
2022/10/04
無名クラスの変換の仕組みの改良
2022/10/07
プログラムの整理(詳細は以下)
DataStoreから旧バージョンの情報保存系変数を削除
それに伴い単一変換版プログラムを削除
加えて、Multiとついていたプログラム(J2KConverterMulti, J2KConverterSupporterMulti, J2KConverterFullMulti)の名称からMultiを削除
debugするために旧J2KConverterからVisitorを削除し、空のvisitorを持ったASTViewerを作成
2022/10/18
GoogleSamplesのプロジェクト18個を用いたテストとそれによる修正
2022/10/25
ConverterSupporterのlambdaExprとConverterのSwitchStmt,SwitchExprに修正、lambdaExprは修正完了
ConverterSupporterのSwitchStmtとSwitchExprを修正、完了
2022/10/31
ConverterSupporterのMethodCallExpr修正、 InBlockFirstVisitorとInBlockSecondVisitorにSynchronizedStmt追加
GoogleSamples18プロジェクト全て出力可能に
InitializerSecondVisitor、ConstructorSecondVisitorに匿名クラスの情報解析用の仕組み追加
ThrowStmtの解析機能追加
2022/11/01
InstanceOf修飾子の変換・解析機能追加
UnaryExprの解析機能変更、伴って各Stmtのcondition, update, compareの変換機能も変更
labelの出力タイミングを変更、それに伴ってlabelが出力される可能性のあるStmtの冒頭のインデントの付け方を変更
lambda式の時のreturn記述の出力を変更
2022/11/07
ConverterSupporterのアルゴリズムを変更
2022/11/08
MethodReferenceExprの変換機能をコメントアウトによってオミット
2022/11/10
ConverterSupporterの出力を確認、想定と違う箇所が見られたので、再度アルゴリズム修正
2022/11/11
ConverterSupporterのアルゴリズム変更、常にクラス直下から解析中のブロックまでの情報群を保持するように
解析終了後、常に最新の情報になるように保存する仕組みを追加
2022/11/14
BaseInformationにstaticであるどうかを記したisStaticとkotlinでprivateなものにするかを決めるisKotlinPrivateを追加
伴って、BlockInformationとFieldInformationからisStaticを削除
2022/11/15
if文の変換時に起きていたvisitorの設定ミスを修正
1回目の情報解析の際に、switchExpr、ObjectCreationExprなど、Assign文の右辺に記述出来る情報の取得ミスを修正
あるクラスが記述されたファイルの場所を特定する機能searchCI_FromImportを作成(機能のみ作成、解析機能には組み込んでいない)
変数の型と初期化の際の型が違う時、初期化の型に揃える仕組みを作成開始
上記に伴い、変数情報FieldInformationに、代入される型を記した変数valueTypeを追加
コードの整理
2022/11/21
変数などがオーバーライドされるか否かに関連する変数isOverrideを追加、isOpenをBaseInformationに移動
継承される側の判定(isOpen)、継承する側の判定(isOverride)の判断機能を追加
インクリメント、デクリメントなどのUnaryExprやASSIGN以外のAssignExprの変換出力を変更
2022/11/22
インデントなどの細かい修正
importの記述からファイルの場所を特定する機能を追加
2022/11/25
UnaryExprに含まれる符号付きの数字の変換に関して、Unaryに符号かどうかを判断する変数isSignを追加
何も書いてない(EmptyStmt)記述に対し、MakeBlock, InBlockにEmptyStmtの変換を追加(何もはいってないブロックを出力)
スーパークラスとサブクラスの関係を明記する(isOpen)⇨同一名が複数あるパターンは未対応
クラスを直接参照する時の扱い⇨同一ファイルのみ可能にする
2022/11/28
ver0.8開発完了
ラムダ式に関する変換機能追加の準備
ver0.9開発開始
2022/11/29
ObjectCreationExprの変換アルゴリズムを変更
LambdaExprの変換アルゴリズムを変更
BlockInformationのparamTypesとFieldInformation、MethodInformationのTypeの型をそれぞれStringからTypeに変更
BlockStmtの変換アルゴリズムを変更
foreachStmtの情報解析システムを実装、伴って変換システムのアルゴリズムを変更
2022/12/05
情報解析プログラムのうち、LambdaExprやObjectCreationExpr内のrangeやrangeStructureについての扱いを修正
ディレクトリ、ファイルを作成する仕組みを持つConvertOutputerの修正
GoogleSamplesプログラムのコンバートによる出力確認作業開始
2022/12/06
プログラムが6個以下のGoogleSamplesプログラムのコンバート
2022/12/09
volatile修飾子、多重代入、androidにおけるリソースid参照、equalsIgnoreCaseに対応
非null値アサーション演算子をつける基準を変更
extends、implementsのクラスの変換アルゴリズムを少し変更
AssignVisitorの変数typeの型をStringからTypeに変更
2022/12/15
GoogleSamplesプログラムのコンバート範囲を9個以下に変更
非null値アサーション演算子をつける基準を変更
2022/12/18
変数の情報参照の際の仕組みを少し変更
2022/12/19
情報解析の関数analysisの引数を変更(想定した範囲の解析が出来ていなかったため)
primitive型のデフォルトの型をnon-nullに変更
2022/12/20
配列のサイズを確認する変数lengthの変換に対応
ArrayCreationLevelの正しい解析を実装
上記に伴いArrayCreationExprの変換アルゴリズムを変更、変換用再帰関数ArrayConverter実装
2022/12/21
Javaの特定の関数がKotlinでは変数扱いになる変換に対応
GoogleSamplesプログラムのコンバート範囲を15個以下に変更
MethodReferenceExprの変換に対応
ThisExprに詳細な変換機能追加
AssignVisitorにAssignExprの変換機能を追加
2022/12/26
Supporterのtype, typeDef変数の型をTypeに変更
companionの出力システム実装
変数と値の型違いへの対応出力実装
2022/12/27
ラッパークラスのtoString()コンバートに対応
Stringのjoin関数のコンバート対応
import文の出力方法を少し変更
リテラル出力の際の型違い出力機能を一時的にオミット
多重代入の情報収集機能をSupporterに追加
2022/12/28
評価用のGoogleSamplesプロジェクトを一度初期化(評価用の修正をしすぎたため)
キャストの変換システムを修正
プリミティブ型と判断された変数への後置演算子出力をしないように修正
2022/12/29
ver0.9開発完了、ver1.0(正式版)開発開始
クラス宣言時のダイアモンド演算子内の変換システムを変更
情報取集クラスにおいて、型の情報が正しく代入されていなかった事象を修正
列挙型クラスのstatic修飾子を持つ記述を変換していなかった事象を修正
関数における継承の変換システムを作成
関数において、返り値として参照する変数の型が変換に伴って変更される場合に対応
匿名関数の内部解析を行う際に情報がdequeに追加されていなかった事象を修正
ObjectCreationExprの情報収集、変換できる範囲を拡張
GoogleSamples18プロジェクト全てのコンバート出力に成功
2022/12/30
conditionの内部に記述されるAssignExprの変換に対応
ライブラリ情報の紐付け解析を修正
import文の出力方法変更
Companion出力が可能な際、対象にライブラリが紐づいている場合にはしないように修正
for文のinitialにて宣言がされる際、同一のスコープに同じ名前の変数がある場合には代入文になるように修正
変数の型情報が正しく引き継がれていない事象を修正
2023/01/01
拡張機能の実装着手
カスタムアクセサ変換用のフラグ変数isCustomAccessFlag追加
non-null化機能に関わる仕組みを修正
2023/01/06
switch文においてdefault記述がないときに何もしないelseブロックを出力するように修正
関数参照においてスコープの出力に意図しないタイミングで?が出力されている事象を修正
特定の関数の引数をnon-null/nullableにする関数SFP_NCを実装
switch文のラベルにおいて変数を使用している際、selectorがプリミティブ型、もしくはString形でない場合にその型をスコープとして明記するように修正
ラムダ式を匿名関数化する仕組みを修正
2023/01/07
関数の返り値の出力を一部修正
情報解析の際、isReturnNullの値が一度trueになったあとfalseにならないように修正
情報解析にtry-catch-finally追加
final修飾子とopen/override修飾子が同時に出力されないようにopen/override修飾子のフラグがtrueになる条件を修正
ver1.0リリース、ver1.1開発開始
2023/01/17
軽微な修正
2023/01/20
ver1.1終了、ver1.2へ
拡張機能2の機能に関して，定義位置の変更と出力条件の修正
カスタムアクセサ変換の拡張機能実装
2023/01/21
ライブラリ解析テスト用のクラスLibraryTry作成
2023/01/22
java.baseライブラリの解析をデフォルト実装
ライブラリ専用DataStore変数と解析変数isLibraryCheckなどを追加
後置演算子の出力や、変数・関数情報の取得が正しく行われていなかった状態を修正
2023/01/24
Androidライブラリの解析機能追加
シェルスクリプトにAndroidライブラリのパス変数Aを追加
2023/02/13
引き継ぎのためのコード整理
(各種ノードのvisit関数の順番をアルファベット順に整理、特定のvisitにしか関わらない関数はvisitのすぐ下に)
2023/03/04
kzm0308の研究としての開発終了(以後も続く)


今後の課題(2023年度以降)
・拡張３の実装
・その他拡張機能の追加検討
・ユーザ側の評価実験
・ライブラリ解析機能の改善
・拡張機能をユーザが選ぶ基準(ユーザがどのようにして拡張機能を選ぶのか？ ということの整理)
・その他ブラッシュアップ


〜〜〜ここから下は開発時のメモとかもあるので適宜参考にしていただけるとありがたい〜〜〜

同じクラス名の優先度

同一プログラムファイル内のやつ(インナークラス、外のクラス問わず)＞別のファイルにあり、パッケージに属しているやつ＞パッケージの中にないやつ(アクセス不可)
(java以下にはディレクトリを作ることができないのでこんな構造になる)
なのでアクセス順は『同一pathAbsを持つデータ内』＞『自分以外のプログラムのうち、パッケージに属しているやつ』
パッケージに属しているならば一発で型が分かるし、何も書いてない場合は優先度がある
書いてない場合は同一のパッケージ内しかない。そこに入っていない場合にはimport文から把握できる

パッケージに属していないならば、インナークラスなどで同一ファイルにない場合は、同一pathAbsでアクセスできる
インナークラスがある場合はそのクラスにしかアクセスできない

nullをプログラム中から排除するためのシステム構築
変数が参照される時・値が書き込まれるパターンとしてどんな場合が想定できるか?
・書き込み：代入、初期化、インクリメント/デクリメント
・読み込み：書き込み時の値参照(代入、初期化)、メソッドの引数になった時、配列の初期化要素の1つになった時、計算式内部でのアクセス
          フィールドそのものへのアクセス、値の評価(do-while,while,ifなどのcondition、forのcompareなど)
          return文で返す時


サードパーティ製のライブラリが使われている箇所の問題
サードパーティ製ライブラリかどうかは、確認する際のMethodの確認情報からわかる。
何も取得できなければ可能性があるので、そこから値を得ている場合は、nullの可能性があるとしてnullable定義する
もしくはvalを挟んで中間の緩衝材とする手もある

アルゴリズム通りにできているかの確認を行うクラスを書く(ClassT1とか)
全部String型の文字列の出力を行うクラスで、初期値を書かずに、別の場所で定義するjavaを書いて、それを変換し、変換前と同様の動作をするかどうかを見る
もちろん同じ動作をすれば問題なし
1通常に宣言代入、2宣言＋static初期化子で初期化、3宣言＋初期化子で初期化、4宣言+コンストラクタで初期化、5宣言+main関数で初期化
6 2-5で先に読み出し記述をどこかに書く
これらを全てクリアできれば、少なくともクラスのインスタンス生成時に必ず行われるものの中では初期値を確保できる
ただし、他の箇所での代入などはどうしようもない(順番が不定であるため確認できない)

初期値生成が可能かどうか(lateinit)つけられるかどうかの判断　フィールドの初期値 + インスタンス生成時のstatic初期化子→初期化子→コンストラクタまで
null代入の捜索範囲　サードパーティ製のライブラリを除いたプロジェクト中の全てのプログラム

データフロー解析(Dataflow analysis) SSA(static single assignment)形式(form)データフロー解析の関連用語
制御フローグラフ
別言語の利点を活用したい：トランスパイラを利用する理由

○そもそもこのJ2KConverterの利点・目的ってなんだ
自動変換の需要：手書きよりも遥かに早いスピードで別言語への書き換えができる
IntelliJ系列との比較：ほぼ同一の条件を持つJavaコードの変換結果が二分しない、必ず同じ結果になる(気にしておくべき)
IntelliJ系列との比較２：自動変換後出来る限りそのまま使えるような変換を行う(修正を必要としない)(ここが今の所のウリ)
→現状何ができて何ができないのかを明確化することで、今後の課題にも繋がるし、第三者の更なる発展にも繋がる
導入の容易性：コマンドライン化したことで、test.shを実行できる環境さえあれば使用可能
　　　　　　　いじる中身は全て.shファイルに集約してあるので自動変換プログラム自体はいじる必要なし(メインの売りにはしづらいけど、まああるかな、くらい)
？コードの保存容易性(IntelliJ系列との比較３)：バックアップを取らなくてもJavaコードが残る仕組みなので、照らし合わせも容易(違いの把握くらい、に留まる)
拡張・模倣の容易性：J2KConverterの取っている手法(変換元のparserを使用し、構文木を辿りながら変換)
                を元にしてJavaから別言語への変換器が作れる、もっといえばいろんなのが作れる
                (これはあくまでも当たり前の話。近似性のおかげで実装を簡略化できる、ということは言える)

non-null化の促進に関する関連研究の調査